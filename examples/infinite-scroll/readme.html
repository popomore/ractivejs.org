<p>One of the particular challenges of front-end development is encapsulating functionality in a reusable form. With the rise of things like AMD it's getting better, but it's still hard to find the sweet spot between general solutions (abstract, reusable) and specific ones (better optimised, less verbose configuration).</p>

<p>This is particularly true where the DOM is concerned. One of the goals of <span class='logo'>Ractive.js</span> is to provide a platform for creating these reusable modules.</p>

<p>Take this infinite scroll widget as an example. It's a fairly basic module &ndash; it extends <code>Ractive</code> with some hooks for loading older data when the user scrolls to a certain point, and a simple polling mechanism for loading newer data.</p>

<p>But it doesn't actually make any API requests. That's the job of our app &ndash; to use the hooks provided by the module. In this example, we're loading the <a href='https://app.net'>App.net</a> global stream &ndash; for that we need a function that will make the request using JSONP, and some App.net-specific logic for extracting the data we need from the response (such as getting the ID of the most recent post, so we know which data we need to request next time we poll).</p>

<p>The template also uses partials, so that we can inject app-specific template snippets that reflect the shape of the data we get back from the API.</p>

<p>And because we're using <span class='logo'>Ractive.js</span>, we don't have to faff about with a special <code>Post</code> view class with its own render method, or any such nonsense &ndash; it just works, slick transitions and all.</p>